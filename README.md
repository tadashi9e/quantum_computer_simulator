
量子計算機シミュレータ
================

- qc.h  ヘッダファイル
- qc.cc ソースファイル
- test_*.cc テストプログラム
- setup.py Python モジュール

前提
====

C++ コンパイラ(C++11)
Python3 (Python モジュールを用いる場合)

Python モジュールから利用する場合
===========

導入方法
----------

setup.py を用いて python モジュールを導入する
```sh
 $ python3 setup.py install --user
```

使用方法
----------

qc モジュールの関数実行として、対話的に（状態を確認しながら）量子ゲートを実行する。

- モジュールのインポート
```python
>>> from qc import *
0: |(1,0)| = 1
```
- reset(): 初期化。モジュールインポート時に同じ処理が実行される。
```python
>>> reset()
0: |(1,0)| = 1
```
- h(target): アダマールゲート。引数に与えられた量子ビットに対して適用する。
```python
0: |(1,0)| = 1
>>> h(0)
0: |(0.707107,0)| = 0.5
1: |(0.707107,0)| = 0.5
```
- h(target_min, target_max): アダマールゲート。引数に与えられた範囲の量子ビットすべてに対して適用する。
```python
0: |(1,0)| = 1
>>> h(3)
0000: |(0.25,0)| = 0.0625
1000: |(0.25,0)| = 0.0625
0100: |(0.25,0)| = 0.0625
1100: |(0.25,0)| = 0.0625
0010: |(0.25,0)| = 0.0625
1010: |(0.25,0)| = 0.0625
0110: |(0.25,0)| = 0.0625
1110: |(0.25,0)| = 0.0625
0001: |(0.25,0)| = 0.0625
1001: |(0.25,0)| = 0.0625
0101: |(0.25,0)| = 0.0625
1101: |(0.25,0)| = 0.0625
0011: |(0.25,0)| = 0.0625
1011: |(0.25,0)| = 0.0625
0111: |(0.25,0)| = 0.0625
1111: |(0.25,0)| = 0.0625
```
- x(target): パウリ X ゲート。
```python
0: |(1,0)| = 1
>>> x(2)
001: |(1,0)| = 1
```
- y(target): パウリ Y ゲート。
- z(target): パウリ Z ゲート。
- rz(target, phase): 位相シフトゲート。
- cx(control, target): 制御付きパウリ X ゲート。
- cy(control, target): 制御付きパウリ Y ゲート。
- cz(control, target): 制御付きパウリ Z ゲート。
- ccx(control1, control2, target): 制御付きパウリ X ゲート（トフォリゲート）。
- ccy(control1, control2, target): 制御付きパウリ Y ゲート。
- ccz(control1, control2, target): 制御付きパウリ Z ゲート。
- m(target): 量子ビットの観測を行い、観測結果を bool 値として返す。
```python
0: |(0.707107,0)| = 0.5
1: |(0.707107,0)| = 0.5
>>> m(0)
1: |(1,0)| = 1
True
```
- set_interactive(False): 引数が False なら、以降は実行ごとの量子状態表示を行わない。
- dump(): 量子状態（状態ベクトルとそれに対応する確率振幅）を表示する。

例
--

```python
>>> from qc import *
0: |(1,0)| = 1
>>> h(1)
00: |(0.707107,0)| = 0.5
01: |(0.707107,0)| = 0.5
>>> cx(1, 2)
000: |(0.707107,0)| = 0.5
011: |(0.707107,0)| = 0.5
>>> cx(0, 1)
000: |(0.707107,0)| = 0.5
011: |(0.707107,0)| = 0.5
>>> h(0)
000: |(0.5,0)| = 0.25
100: |(0.5,0)| = 0.25
011: |(0.5,0)| = 0.25
111: |(0.5,0)| = 0.25
>>> m(1)
011: |(0.707107,0)| = 0.5
111: |(0.707107,0)| = 0.5
True
>>> 
```

C++ ソースから利用する場合
====================

qc.h をヘッダファイルとして以下の内容のシミュレーションプログラムを記述する。

1. qc::qbit 型変数として、使用する量子変数を宣言する。
2. 量子変数を初期化する。すべての量子変数が |0> 状態となる。
3. 量子変数を操作する。
5. 観測操作を行い、結果を得る。

記述したプログラムを qc.cc とともにコンパイルする。

量子ビットの宣言
----------------

コンストラクタ qc::qbit() あるいは 
qc::qbit(std::string const& name) で量子ゲートを宣言する。
引数に名前を与えられた場合には、デバッグ時にその名前付きで表示する。

初期化
------

```c++
void qc::reset()
```

|000...000> の確率を 1 にする。それ以外は 0。

演算操作
--------

#### アダマールゲート

```c++
void qc::hadamard(qbit const& q);
```

量子変数 q にアダマール変換を行う。

```c++
void qc::hadamard_for_all();
```

その時点で宣言されているすべての量子変数についてアダマールゲートを適用する。

#### パウリ X ゲート

```c++
void qc::pauli_x(qbit const& q);
```

#### パウリ Y ゲート

```c++
void qc::pauli_y(qbit const& q);
```

#### パウリ Z ゲート

```c++
void qc::pauli_z(qbit const& q);
```

#### 位相ゲート

```c++
void qc::cphase(qbit const& q, std::complex<double> const& phase);
```

ここでは phase には位相 $\theta$ ではなく ${e}^{i \theta}$ を与える。

#### 制御ノットゲート

```c++
void qc::cx(qbit const& control_q, qbit const& target_q);
void qc::ccx(qbit const& control1_q, qbit const& control2_q,
             qbit const& target_q);
```

観測
----

```c++
bool qc::measure(qbit const& q);
```

観測を行い、その結果をブール値で返す。

現実の量子計算機ではありえない操作
----------------------------------

#### デバッグ表示

```c++
void qc::dump(std::string const& title);
```

量子ビットの一覧、および、その時点での各状態の振幅を表示する。

#### 量子状態のバックアップ作成、およびそのリストア

```c++
extern frozen_ptr backup();
extern void restore(frozen_ptr const& frozenptr);
```

同じ量子状態について測定操作を繰り返す場合などにおいて、計算時間を節約するために用いる。

テストプログラム
===========

```
test_add <n_bits> <n_loop>
```
指定されたビット数での足し算を行い、指定された回数の測定を繰り返す。

```
test_teleport
```
量子テレポーテーションのテスト。
